<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë§ˆë¹„ë…¸ê¸° ëª¨ë°”ì¼ ì•…ë³´ ë³€í™˜ê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            background: #f8fafc;
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #6366f1;
            background: #f1f5f9;
        }

        .upload-section.dragover {
            border-color: #4f46e5;
            background: #eef2ff;
        }

        .upload-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 20px;
            background: #6366f1;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
        }

        .upload-text {
            font-size: 1.2rem;
            color: #475569;
            margin-bottom: 15px;
        }

        .upload-subtext {
            font-size: 0.9rem;
            color: #64748b;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: #6366f1;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .upload-btn:hover {
            background: #4f46e5;
        }

        .preview-section {
            display: none;
            margin-bottom: 30px;
        }

        .preview-image {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .options-section {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .options-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 15px;
        }

        .option-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-item label {
            font-size: 0.9rem;
            color: #475569;
        }

        .convert-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .convert-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .convert-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .result-section {
            display: none;
        }

        .result-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 15px;
        }

        .mml-output {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .result-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            background: #6366f1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .action-btn:hover {
            background: #4f46e5;
        }

        .action-btn.success {
            background: #10b981;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.9rem;
            color: #64748b;
            margin-bottom: 10px;
        }

        .quick-test-section {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .quick-test-title {
            font-weight: 600;
            color: #92400e;
            margin-bottom: 10px;
        }

        .quick-test-btn {
            background: #f59e0b;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            margin-right: 10px;
        }

        .quick-test-btn:hover {
            background: #d97706;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .audio-controls {
            background: #f1f5f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .play-btn {
            background: #059669 !important;
            min-width: 120px;
        }

        .play-btn:hover {
            background: #047857 !important;
        }

        .play-btn.playing {
            background: #dc2626 !important;
        }

        .play-btn.playing:hover {
            background: #b91c1c !important;
        }

        .tempo-control, .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: #475569;
        }

        .tempo-control input, .volume-control input {
            width: 80px;
        }

        .tempo-control span, .volume-control span {
            min-width: 60px;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .option-group {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸµ ë§ˆë¹„ë…¸ê¸° ëª¨ë°”ì¼ ì•…ë³´ ë³€í™˜ê¸°</h1>
            <p>ì•…ë³´ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ë§ˆë¹„ë…¸ê¸° ëª¨ë°”ì¼ìš© MML ì½”ë“œë¡œ ë³€í™˜í•´ë“œë¦½ë‹ˆë‹¤</p>
        </div>

        <div class="main-content">
            <div class="error-message" id="errorMessage"></div>

            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">ğŸ“„</div>
                <div class="upload-text">ì•…ë³´ ì´ë¯¸ì§€ ë˜ëŠ” MIDI íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œí•˜ì„¸ìš”</div>
                <div class="upload-subtext">ì§€ì› í˜•ì‹: JPG, PNG, GIF, PDF, MIDI (ìµœëŒ€ 10MB)</div>
                <input type="file" id="fileInput" class="file-input" accept="image/*,.pdf,.gif,.mid,.midi">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    íŒŒì¼ ì„ íƒ
                </button>
            </div>

            <div class="preview-section" id="previewSection">
                <img id="previewImage" class="preview-image" alt="ì—…ë¡œë“œëœ ì•…ë³´ ë¯¸ë¦¬ë³´ê¸°">
            </div>

            <div class="options-section">
                <div class="options-title">ë³€í™˜ ì˜µì…˜</div>
                <div class="option-group">
                    <div class="option-item">
                        <input type="radio" id="keyC" name="key" value="C" checked>
                        <label for="keyC">Cì¥ì¡°</label>
                    </div>
                    <div class="option-item">
                        <input type="radio" id="keyG" name="key" value="G">
                        <label for="keyG">Gì¥ì¡°</label>
                    </div>
                    <div class="option-item">
                        <input type="radio" id="keyF" name="key" value="F">
                        <label for="keyF">Fì¥ì¡°</label>
                    </div>
                </div>
                <div class="option-group">
                    <div class="option-item">
                        <input type="checkbox" id="includeChords" checked>
                        <label for="includeChords">í™”ìŒ í¬í•¨</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="simplifyRhythm">
                        <label for="simplifyRhythm">ë¦¬ë“¬ ë‹¨ìˆœí™”</label>
                    </div>
                </div>
            </div>

            <button class="convert-btn" id="convertBtn" onclick="convertSheetMusic()" disabled>
                ì•…ë³´ ë³€í™˜í•˜ê¸°
            </button>

            <div class="quick-test-section">
                <div class="quick-test-title">ğŸš€ ë¹ ë¥¸ í…ŒìŠ¤íŠ¸</div>
                <p style="font-size: 0.85rem; color: #92400e; margin-bottom: 10px;">
                    ì•…ë³´ ë¶„ì„ì´ ì˜¤ë˜ ê±¸ë¦°ë‹¤ë©´ ìƒ˜í”Œ MMLë¡œ ë¨¼ì € í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”!
                </p>
                <button class="quick-test-btn" onclick="loadSampleMML('twinkle')">ë°˜ì§ë°˜ì§ ì‘ì€ë³„</button>
                <button class="quick-test-btn" onclick="loadSampleMML('canon')">ìºë…¼</button>
                <button class="quick-test-btn" onclick="loadSampleMML('mary')">ë©”ë¦¬ì˜ ì–‘</button>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div class="progress-text" id="progressText">ì•…ë³´ë¥¼ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p style="font-size: 0.85rem; color: #64748b;">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”. ë³µì¡í•œ ì•…ë³´ì¼ìˆ˜ë¡ ì‹œê°„ì´ ë” ê±¸ë¦½ë‹ˆë‹¤.</p>
            </div>

            <div class="result-section" id="resultSection">
                <div class="result-title">ë³€í™˜ëœ MML ì½”ë“œ</div>
                <div class="mml-output" id="mmlOutput"></div>
                <div class="audio-controls">
                    <button class="action-btn play-btn" id="playBtn" onclick="togglePlayback()">â–¶ï¸ ë¯¸ë¦¬ë“£ê¸°</button>
                    <button class="action-btn" id="stopBtn" onclick="stopPlayback()" disabled>â¹ï¸ ì •ì§€</button>
                    <div class="tempo-control">
                        <label for="tempoSlider">í…œí¬:</label>
                        <input type="range" id="tempoSlider" min="60" max="200" value="120">
                        <span id="tempoValue">120 BPM</span>
                    </div>
                    <div class="volume-control">
                        <label for="volumeSlider">ë³¼ë¥¨:</label>
                        <input type="range" id="volumeSlider" min="0" max="100" value="50">
                        <span id="volumeValue">50%</span>
                    </div>
                </div>
                <div class="result-actions">
                    <button class="action-btn" onclick="copyToClipboard()">í´ë¦½ë³´ë“œì— ë³µì‚¬</button>
                    <button class="action-btn" onclick="downloadMML()">MML íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
                    <button class="action-btn" onclick="resetConverter()">ë‹¤ì‹œ ë³€í™˜í•˜ê¸°</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/midi-parser-js@4.0.4/dist/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/verovio@4.1.0/dist/verovio-toolkit-wasm.js"></script>
    <script>
        let uploadedFile = null;
        let convertedMML = '';
        let canvasContext = null;
        let imageData = null;

        // ì˜¤ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜
        let audioContext = null;
        let isPlaying = false;
        let currentTimeout = null;
        let noteScheduler = null;
        let activeOscillators = []; // í™œì„± ì˜¤ì‹¤ë ˆì´í„° ì¶”ì 
        
        // Verovio íˆ´í‚· ë³€ìˆ˜
        let verovio = null;

        // íŒŒì¼ ì—…ë¡œë“œ ê´€ë ¨ ì´ë²¤íŠ¸
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const previewSection = document.getElementById('previewSection');
        const previewImage = document.getElementById('previewImage');
        const convertBtn = document.getElementById('convertBtn');
        const errorMessage = document.getElementById('errorMessage');

        fileInput.addEventListener('change', handleFileSelect);
        uploadSection.addEventListener('dragover', handleDragOver);
        uploadSection.addEventListener('dragleave', handleDragLeave);
        uploadSection.addEventListener('drop', handleFileDrop);

        // í…œí¬ ë° ë³¼ë¥¨ ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸ ë° Verovio ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            const tempoSlider = document.getElementById('tempoSlider');
            const volumeSlider = document.getElementById('volumeSlider');
            
            if (tempoSlider) {
                tempoSlider.addEventListener('input', function() {
                    document.getElementById('tempoValue').textContent = this.value + ' BPM';
                });
            }
            
            if (volumeSlider) {
                volumeSlider.addEventListener('input', function() {
                    document.getElementById('volumeValue').textContent = this.value + '%';
                });
            }
            
            // Verovio íˆ´í‚· ì´ˆê¸°í™”
            initializeVerovio();
        });

        // Verovio ì´ˆê¸°í™”
        async function initializeVerovio() {
            try {
                if (typeof verovio_module !== 'undefined') {
                    console.log('Verovio íˆ´í‚· ë¡œë”© ì¤‘...');
                    verovio = new verovio_module.toolkit();
                    console.log('Verovio íˆ´í‚· ì´ˆê¸°í™” ì™„ë£Œ');
                } else {
                    console.warn('Verovio ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê³ ê¸‰ ê¸°ëŠ¥ì´ ì œí•œë©ë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('Verovio ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            uploadSection.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            uploadSection.classList.remove('dragover');
        }

        function handleFileDrop(event) {
            event.preventDefault();
            uploadSection.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        function processFile(file) {
            // íŒŒì¼ í¬ê¸° ì²´í¬ (10MB)
            if (file.size > 10 * 1024 * 1024) {
                showError('íŒŒì¼ í¬ê¸°ëŠ” 10MB ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }

            // íŒŒì¼ í˜•ì‹ ì²´í¬
            const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'application/pdf', 'audio/midi', 'audio/mid'];
            if (!allowedTypes.includes(file.type) && !file.name.toLowerCase().endsWith('.mid') && !file.name.toLowerCase().endsWith('.midi')) {
                showError('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. JPG, PNG, GIF, PDF, MIDI íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
                return;
            }

            uploadedFile = file;
            hideError();

            // íŒŒì¼ íƒ€ì…ë³„ ì²˜ë¦¬
            if (file.type === 'application/pdf') {
                processPDF(file);
            } else if (file.type === 'image/gif') {
                processGIF(file);
            } else if (file.name.toLowerCase().endsWith('.mid') || file.name.toLowerCase().endsWith('.midi')) {
                processMIDI(file);
            } else {
                // ì¼ë°˜ ì´ë¯¸ì§€ íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewImage.src = e.target.result;
                    previewSection.style.display = 'block';
                    convertBtn.disabled = false;
                };
                reader.readAsDataURL(file);
            }
        }

        // PDF ì²˜ë¦¬ í•¨ìˆ˜
        async function processPDF(file) {
            try {
                // PDFë¥¼ Canvasë¡œ ë³€í™˜í•˜ì—¬ ë¯¸ë¦¬ë³´ê¸° ìƒì„±
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // PDF ì²« í˜ì´ì§€ë¥¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜
                const reader = new FileReader();
                reader.onload = async function(e) {
                    // ê°„ë‹¨í•œ PDF í‘œì‹œë¥¼ ìœ„í•œ placeholder
                    canvas.width = 400;
                    canvas.height = 500;
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#666';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('PDF ì•…ë³´', canvas.width/2, canvas.height/2 - 20);
                    ctx.font = '16px Arial';
                    ctx.fillText(file.name, canvas.width/2, canvas.height/2 + 20);
                    
                    previewImage.src = canvas.toDataURL();
                    previewSection.style.display = 'block';
                    convertBtn.disabled = false;
                };
                reader.readAsArrayBuffer(file);
            } catch (error) {
                console.error('PDF ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
                showError('PDF íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // GIF ì²˜ë¦¬ í•¨ìˆ˜
        async function processGIF(file) {
            try {
                const reader = new FileReader();
                reader.onload = function(e) {
                    // GIFì˜ ì²« ë²ˆì§¸ í”„ë ˆì„ì„ Canvasë¡œ ì¶”ì¶œ
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        // ì²« ë²ˆì§¸ í”„ë ˆì„ë§Œ ê·¸ë¦¬ê¸° (GIF ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€)
                        ctx.drawImage(img, 0, 0);
                        
                        // Canvasë¥¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜í•˜ì—¬ ë¯¸ë¦¬ë³´ê¸°ì— í‘œì‹œ
                        previewImage.src = canvas.toDataURL();
                        previewSection.style.display = 'block';
                        convertBtn.disabled = false;
                    };
                    
                    img.onerror = function() {
                        // GIF ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì›ë³¸ ê·¸ëŒ€ë¡œ í‘œì‹œ
                        previewImage.src = e.target.result;
                        previewSection.style.display = 'block';
                        convertBtn.disabled = false;
                    };
                    
                    img.src = e.target.result;
                };
                
                reader.onerror = function() {
                    showError('GIF íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                };
                
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('GIF ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
                showError('GIF íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // MIDI íŒŒì¼ ì²˜ë¦¬ í•¨ìˆ˜
        async function processMIDI(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const midiData = MidiParser.parse(arrayBuffer);
                
                console.log('MIDI íŒŒì¼ íŒŒì‹±ë¨:', midiData);
                
                // MIDI ì •ë³´ë¥¼ ë¯¸ë¦¬ë³´ê¸°ë¡œ í‘œì‹œ
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 400;
                canvas.height = 200;
                
                // MIDI ì •ë³´ ì‹œê°í™”
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                
                const trackCount = midiData.track ? midiData.track.length : 0;
                const ticksPerBeat = midiData.timeDivision || 480;
                
                ctx.fillText('ğŸµ MIDI íŒŒì¼', canvas.width/2, 40);
                ctx.font = '12px Arial';
                ctx.fillText(`íŒŒì¼ëª…: ${file.name}`, canvas.width/2, 70);
                ctx.fillText(`íŠ¸ë™ ìˆ˜: ${trackCount}ê°œ`, canvas.width/2, 90);
                ctx.fillText(`í‹±/ë°•ì: ${ticksPerBeat}`, canvas.width/2, 110);
                ctx.fillText('MML ë³€í™˜ ì¤€ë¹„ ì™„ë£Œ', canvas.width/2, 140);
                
                previewImage.src = canvas.toDataURL();
                previewSection.style.display = 'block';
                convertBtn.disabled = false;
                
                // MIDI ë°ì´í„°ë¥¼ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
                window.currentMidiData = midiData;
                
            } catch (error) {
                console.error('MIDI íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
                showError('MIDI íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. íŒŒì¼ì´ ì†ìƒë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            }
        }

        async function convertSheetMusic() {
            if (!uploadedFile) {
                showError('ë¨¼ì € ì•…ë³´ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.');
                return;
            }

            // ë¡œë”© í‘œì‹œ
            document.getElementById('loading').style.display = 'block';
            convertBtn.disabled = true;
            document.getElementById('resultSection').style.display = 'none';

            try {
                // ì„ íƒëœ ì˜µì…˜ë“¤ ê°€ì ¸ì˜¤ê¸°
                const selectedKey = document.querySelector('input[name="key"]:checked').value;
                const includeChords = document.getElementById('includeChords').checked;
                const simplifyRhythm = document.getElementById('simplifyRhythm').checked;

                // MIDI íŒŒì¼ì¸ ê²½ìš° ì§ì ‘ ë³€í™˜
                if (window.currentMidiData) {
                    updateProgress(20, 'MIDI ë°ì´í„° ë¶„ì„ ì¤‘...');
                    const mmlCode = convertMIDIToMML(window.currentMidiData, selectedKey, includeChords, simplifyRhythm);
                    updateProgress(100, 'ì™„ë£Œ!');
                    displayResult(mmlCode);
                    return;
                }

                updateProgress(5, 'ì´ë¯¸ì§€ ë¡œë”© ì¤‘...');
                
                // í•œê¸€+ì˜ì–´ OCRì„ ì‚¬ìš©í•œ ì•…ë³´ ë¶„ì„ ì‹œë„
                updateProgress(20, 'OCRì„ ì‚¬ìš©í•œ í…ìŠ¤íŠ¸ ì¸ì‹ ì¤‘...');
                let recognizedText = '';
                try {
                    // í•œêµ­ì–´+ì˜ì–´ ë™ì‹œ ì¸ì‹ìœ¼ë¡œ ì½”ë“œì™€ ê°€ì‚¬ ëª¨ë‘ ê°ì§€
                    const result = await Tesseract.recognize(uploadedFile, 'kor+eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                const progress = Math.floor(20 + (m.progress * 40));
                                updateProgress(progress, `í…ìŠ¤íŠ¸ ì¸ì‹ ì¤‘... ${Math.floor(m.progress * 100)}%`);
                            }
                        }
                    });
                    recognizedText = result.data.text;
                    console.log('OCR ê²°ê³¼ (í•œê¸€+ì˜ì–´):', recognizedText);
                } catch (ocrError) {
                    console.warn('í•œê¸€ OCR ì‹¤íŒ¨, ì˜ì–´ë§Œìœ¼ë¡œ ì¬ì‹œë„:', ocrError);
                    try {
                        const fallbackResult = await Tesseract.recognize(uploadedFile, 'eng', {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    const progress = Math.floor(20 + (m.progress * 40));
                                    updateProgress(progress, `ì˜ì–´ í…ìŠ¤íŠ¸ ì¸ì‹ ì¤‘... ${Math.floor(m.progress * 100)}%`);
                                }
                            }
                        });
                        recognizedText = fallbackResult.data.text;
                        console.log('ì˜ì–´ OCR ê²°ê³¼:', recognizedText);
                    } catch (finalError) {
                        console.warn('ëª¨ë“  OCR ì‹¤íŒ¨:', finalError);
                        recognizedText = '';
                    }
                }
                
                updateProgress(70, 'ì•…ë³´ ì •ë³´ ë¶„ì„ ì¤‘...');
                
                // OCR ê²°ê³¼ì—ì„œ ìŒì•… ê´€ë ¨ ì •ë³´ ì¶”ì¶œ
                const musicInfo = extractMusicInfoFromText(recognizedText);
                console.log('ì¶”ì¶œëœ ìŒì•… ì •ë³´:', musicInfo);
                
                updateProgress(70, 'ì•…ë³´ êµ¬ì¡° ë¶„ì„ ì¤‘...');
                
                // Verovioë¥¼ ì‚¬ìš©í•œ ê³ ê¸‰ ë³€í™˜ ì‹œë„
                let mmlCode;
                if (verovio && musicInfo.hasMusicalContent) {
                    try {
                        updateProgress(80, 'MusicXML ìƒì„± ì¤‘...');
                        const musicXML = generateMusicXMLFromInfo(musicInfo, selectedKey);
                        
                        updateProgress(90, 'MIDI ë³€í™˜ ì¤‘...');
                        const midiData = await convertMusicXMLToMIDI(musicXML);
                        
                        if (midiData) {
                            updateProgress(95, 'MML ìƒì„± ì¤‘...');
                            mmlCode = convertMIDIToMML(midiData, selectedKey, includeChords, simplifyRhythm);
                        } else {
                            throw new Error('MIDI ë³€í™˜ ì‹¤íŒ¨');
                        }
                    } catch (error) {
                        console.warn('ê³ ê¸‰ ë³€í™˜ ì‹¤íŒ¨, ê¸°ë³¸ ë°©ì‹ ì‚¬ìš©:', error);
                        mmlCode = generateMMLFromMusicInfo(musicInfo, selectedKey, includeChords, simplifyRhythm);
                    }
                } else if (musicInfo.hasMusicalContent) {
                    updateProgress(85, 'MML ì½”ë“œ ìƒì„± ì¤‘...');
                    mmlCode = generateMMLFromMusicInfo(musicInfo, selectedKey, includeChords, simplifyRhythm);
                } else {
                    // OCRë¡œ ìŒì•… ì •ë³´ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ í…œí”Œë¦¿ ì œê³µ
                    updateProgress(85, 'ê¸°ë³¸ í…œí”Œë¦¿ ìƒì„± ì¤‘...');
                    mmlCode = generateDefaultMML(selectedKey, includeChords);
                    showError('ì•…ë³´ì—ì„œ ìŒí‘œë¥¼ ìë™ìœ¼ë¡œ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ê¸°ë³¸ í…œí”Œë¦¿ì„ ì œê³µí•©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ í¸ì§‘í•´ì£¼ì„¸ìš”.');
                }
                
                updateProgress(100, 'ì™„ë£Œ!');
                displayResult(mmlCode);
                
            } catch (error) {
                console.error('ì•…ë³´ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
                showError('ì•…ë³´ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. OCR ì¸ì‹ì´ ì‹¤íŒ¨í–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                
                // ì˜¤ë¥˜ ë°œìƒì‹œ ê¸°ë³¸ í…œí”Œë¦¿ ì œê³µ
                const selectedKey = document.querySelector('input[name="key"]:checked').value;
                const includeChords = document.getElementById('includeChords').checked;
                const defaultMML = generateDefaultMML(selectedKey, includeChords);
                displayResult(defaultMML);
            } finally {
                document.getElementById('loading').style.display = 'none';
                convertBtn.disabled = false;
            }
        }

        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateProgress(percent, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (progressFill) progressFill.style.width = percent + '%';
            if (progressText) progressText.textContent = text;
        }

        // í•œê¸€ ì•…ë³´ íŠ¹í™” ìŒì•… ì •ë³´ ì¶”ì¶œ
        function extractMusicInfoFromText(text) {
            console.log('í…ìŠ¤íŠ¸ ë¶„ì„ ì‹œì‘:', text);
            
            const musicInfo = {
                hasMusicalContent: false,
                tempo: null,
                timeSignature: null,
                key: null,
                notes: [],
                chords: [],
                lyrics: [],
                title: null
            };

            if (!text || text.trim().length === 0) {
                return musicInfo;
            }

            // ì›ë³¸ í…ìŠ¤íŠ¸ì™€ ì •ë¦¬ëœ í…ìŠ¤íŠ¸ ëª¨ë‘ ì‚¬ìš©
            const originalText = text;
            const cleanText = text.toLowerCase().replace(/[^\w\sã„±-ã…ã…-ã…£ê°€-í£]/g, ' ');
            console.log('ì •ë¦¬ëœ í…ìŠ¤íŠ¸:', cleanText);

            // ì½”ë“œëª… ê°ì§€ (C, Cm, F#, Bb7 ë“±)
            const chordMatches = originalText.match(/[CDEFGAB][bmM]?[#â™¯bâ™­]?[0-9]*/g);
            if (chordMatches && chordMatches.length > 0) {
                musicInfo.chords = [...new Set(chordMatches)];
                musicInfo.hasMusicalContent = true;
                console.log('ê°ì§€ëœ ì½”ë“œ:', musicInfo.chords);
            }

            // í•œê¸€ ìŒí‘œëª… ê°ì§€ (ë„ë ˆë¯¸íŒŒì†”ë¼ì‹œ)
            const koreanNotes = ['ë„', 'ë ˆ', 'ë¯¸', 'íŒŒ', 'ì†”', 'ë¼', 'ì‹œ'];
            const englishNotes = ['c', 'd', 'e', 'f', 'g', 'a', 'b'];
            
            let noteCount = 0;
            koreanNotes.forEach(note => {
                const matches = originalText.match(new RegExp(note, 'g'));
                if (matches) {
                    noteCount += matches.length;
                    musicInfo.notes.push(note);
                }
            });

            englishNotes.forEach(note => {
                const regex = new RegExp(`\\b${note}\\b`, 'gi');
                const matches = cleanText.match(regex);
                if (matches) {
                    noteCount += matches.length;
                    musicInfo.notes.push(...matches);
                }
            });

            // ê³¡ ì œëª© ì¶”ì¶œ (ì²« ë²ˆì§¸ ì¤„ì´ë‚˜ í° í…ìŠ¤íŠ¸)
            const lines = originalText.split('\n').filter(line => line.trim());
            if (lines.length > 0) {
                const firstLine = lines[0].trim();
                // í•œê¸€ì´ í¬í•¨ë˜ê³  ê¸¸ì´ê°€ ì ë‹¹í•œ ê²½ìš° ì œëª©ìœ¼ë¡œ ê°„ì£¼
                if (/[ê°€-í£]/.test(firstLine) && firstLine.length >= 2 && firstLine.length <= 20) {
                    musicInfo.title = firstLine;
                    musicInfo.hasMusicalContent = true;
                    console.log('ê°ì§€ëœ ì œëª©:', musicInfo.title);
                }
            }

            // ê°€ì‚¬ ê°ì§€ (í•œê¸€ì´ ë§ì´ í¬í•¨ëœ í…ìŠ¤íŠ¸)
            const koreanTextMatch = originalText.match(/[ê°€-í£\s]{10,}/g);
            if (koreanTextMatch) {
                musicInfo.lyrics = koreanTextMatch;
                musicInfo.hasMusicalContent = true;
                console.log('ê°ì§€ëœ ê°€ì‚¬ êµ¬ê°„:', koreanTextMatch.length, 'ê°œ');
            }

            // ë°•ìí‘œ ê°ì§€
            const timeSignatureMatch = originalText.match(/(\d+)\/(\d+)/);
            if (timeSignatureMatch) {
                musicInfo.timeSignature = `${timeSignatureMatch[1]}/${timeSignatureMatch[2]}`;
                musicInfo.hasMusicalContent = true;
            }

            // í…œí¬ ê°ì§€
            const tempoMatch = originalText.match(/(\d+)\s*bpm|tempo\s*[=:]\s*(\d+)|â™©\s*=\s*(\d+)/i);
            if (tempoMatch) {
                musicInfo.tempo = parseInt(tempoMatch[1] || tempoMatch[2] || tempoMatch[3]);
                musicInfo.hasMusicalContent = true;
            }

            // í•œê¸€ ì•…ë³´ íŠ¹ì„±ì„ ê³ ë ¤í•œ ìŒì•… ì½˜í…ì¸  íŒì •
            const hasKoreanContent = /[ê°€-í£]/.test(originalText);
            const hasChords = musicInfo.chords.length > 0;
            const hasNotes = noteCount > 0;
            const hasTitle = musicInfo.title !== null;
            
            if (hasKoreanContent && (hasChords || hasNotes || hasTitle)) {
                musicInfo.hasMusicalContent = true;
            }

            console.log('ìŒì•… ì •ë³´ ì¶”ì¶œ ê²°ê³¼:', {
                hasKorean: hasKoreanContent,
                chordCount: musicInfo.chords.length,
                noteCount: noteCount,
                hasTitle: hasTitle,
                hasContent: musicInfo.hasMusicalContent,
                info: musicInfo
            });

            return musicInfo;
        }

        // ê°ì§€ëœ ìŒì•… ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹¤ì œ MML ìƒì„±
        function generateMMLFromMusicInfo(musicInfo, key, includeChords, simplifyRhythm) {
            console.log('ìŒì•… ì •ë³´ ê¸°ë°˜ MML ìƒì„±:', musicInfo);

            const tempo = musicInfo.tempo || 100; // ë°œë¼ë“œëŠ” ì¢€ ë” ëŠë¦¬ê²Œ
            const volume = 12;
            let mml = `MML@t${tempo}v${volume}o4`;

            // ê°ì§€ëœ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë©œë¡œë”” ìƒì„±
            if (musicInfo.chords && musicInfo.chords.length > 0) {
                console.log('ì½”ë“œ ê¸°ë°˜ ë©œë¡œë”” ìƒì„±:', musicInfo.chords);
                
                // ì½”ë“œë¥¼ MML ìŒí‘œë¡œ ë³€í™˜
                const chordToMML = {
                    'C': ['c', 'e', 'g'], 'Cm': ['c', 'e-', 'g'],
                    'D': ['d', 'f+', 'a'], 'Dm': ['d', 'f', 'a'],
                    'E': ['e', 'g+', 'b'], 'Em': ['e', 'g', 'b'],
                    'F': ['f', 'a', 'c'], 'Fm': ['f', 'a-', 'c'],
                    'G': ['g', 'b', 'd'], 'Gm': ['g', 'b-', 'd'],
                    'A': ['a', 'c+', 'e'], 'Am': ['a', 'c', 'e'],
                    'B': ['b', 'd+', 'f+'], 'Bm': ['b', 'd', 'f+'],
                    // 7th ì½”ë“œë“¤
                    'C7': ['c', 'e', 'g', 'b-'], 'Cm7': ['c', 'e-', 'g', 'b-'],
                    'F7': ['f', 'a', 'c', 'e-'], 'G7': ['g', 'b', 'd', 'f'],
                    'Am7': ['a', 'c', 'e', 'g'], 'Dm7': ['d', 'f', 'a', 'c'],
                    // í”Œë«/ìƒµ ì½”ë“œë“¤
                    'Eb': ['e-', 'g', 'b-'], 'Ab': ['a-', 'c', 'e-'],
                    'Bb': ['b-', 'd', 'f'], 'Bb7': ['b-', 'd', 'f', 'a-']
                };

                // ì¸ì‹ëœ ì½”ë“œë“¤ì„ ìˆœì„œëŒ€ë¡œ ë©œë¡œë””ë¡œ ë³€í™˜
                let usedChords = 0;
                for (const chord of musicInfo.chords.slice(0, 8)) { // ìµœëŒ€ 8ê°œ ì½”ë“œë§Œ
                    const cleanChord = chord.replace(/[â™¯#]/g, '+').replace(/[â™­b]/g, '-');
                    const notes = chordToMML[cleanChord] || chordToMML[cleanChord.replace(/7$/, '')] || ['c'];
                    
                    // ê° ì½”ë“œì˜ ë£¨íŠ¸ ë…¸íŠ¸ë¥¼ ë©œë¡œë””ë¡œ ì‚¬ìš©
                    const rootNote = notes[0];
                    const duration = simplifyRhythm ? 2 : 4;
                    mml += `${rootNote}${duration}`;
                    usedChords++;
                }

                // ì½”ë“œê°€ ë„ˆë¬´ ì ìœ¼ë©´ ê¸°ë³¸ íŒ¨í„´ìœ¼ë¡œ ë³´ì™„
                if (usedChords < 4) {
                    const fillNotes = ['e', 'f', 'g', 'a'];
                    for (let i = usedChords; i < 4; i++) {
                        const duration = simplifyRhythm ? 2 : 4;
                        mml += `${fillNotes[i % fillNotes.length]}${duration}`;
                    }
                }

                // í™”ìŒ íŠ¸ë™ ìƒì„± (ê°ì§€ëœ ì½”ë“œ ê¸°ë°˜)
                if (includeChords) {
                    mml += ',v8o3';
                    for (let i = 0; i < Math.min(musicInfo.chords.length, 6); i++) {
                        const chord = musicInfo.chords[i];
                        const cleanChord = chord.replace(/[â™¯#]/g, '+').replace(/[â™­b]/g, '-');
                        const notes = chordToMML[cleanChord] || chordToMML[cleanChord.replace(/7$/, '')] || ['c'];
                        
                        // ì½”ë“œì˜ ë£¨íŠ¸ ë…¸íŠ¸ë¡œ ë² ì´ìŠ¤ ë¼ì¸
                        mml += `${notes[0]}2`;
                    }
                }

            } else if (musicInfo.notes && musicInfo.notes.length > 0) {
                // ìŒí‘œ ì´ë¦„ ê¸°ë°˜ ìƒì„±
                const noteMap = {
                    'ë„': 'c', 'do': 'c', 'c': 'c',
                    'ë ˆ': 'd', 're': 'd', 'd': 'd',  
                    'ë¯¸': 'e', 'mi': 'e', 'e': 'e',
                    'íŒŒ': 'f', 'fa': 'f', 'f': 'f',
                    'ì†”': 'g', 'sol': 'g', 'g': 'g',
                    'ë¼': 'a', 'la': 'a', 'a': 'a',
                    'ì‹œ': 'b', 'si': 'b', 'b': 'b'
                };

                const uniqueNotes = [...new Set(musicInfo.notes.map(note => noteMap[note.toLowerCase()]).filter(Boolean))];
                
                for (const note of uniqueNotes) {
                    const duration = simplifyRhythm ? 2 : 4;
                    mml += `${note}${duration}`;
                }

                if (includeChords) {
                    mml += ',v8o3';
                    for (let i = 0; i < Math.min(uniqueNotes.length, 4); i++) {
                        mml += `${uniqueNotes[i]}2`;
                    }
                }
            } else {
                // ì„ íƒëœ í‚¤ì— ë§ëŠ” ê¸°ë³¸ ìŠ¤ì¼€ì¼
                const keyScales = {
                    'C': 'cdefgab>c<',
                    'G': 'gabcdef+>g<',
                    'F': 'fgab->cde<'
                };
                const scale = keyScales[key] || keyScales['C'];
                mml += scale;
                
                if (includeChords) {
                    const keyChords = {
                        'C': 'v8o3c2f2g2c2',
                        'G': 'v8o3g2c2d2g2',
                        'F': 'v8o3f2a+2c2f2'
                    };
                    mml += ',' + (keyChords[key] || keyChords['C']);
                }
            }

            console.log('ìƒì„±ëœ MML:', mml + ';');
            return mml + ';';
        }

        // ê¸°ë³¸ MML í…œí”Œë¦¿ ìƒì„±
        function generateDefaultMML(key, includeChords) {
            const keyTemplates = {
                'C': 'MML@t120v12o4cdefgab>c4<',
                'G': 'MML@t120v12o4gabcdef+g4',
                'F': 'MML@t120v12o4fgab>cdef4<'
            };

            let mml = keyTemplates[key] || keyTemplates['C'];

            if (includeChords) {
                const chordMaps = {
                    'C': 'v8o3c2f2g2c2',
                    'G': 'v8o3g2c2d2g2', 
                    'F': 'v8o3f2a+2c2f2'
                };
                mml += ',' + (chordMaps[key] || chordMaps['C']);
            }

            return mml + ';';
        }

        // ìŒì•… ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ MusicXML ìƒì„±
        function generateMusicXMLFromInfo(musicInfo, key) {
            console.log('MusicXML ìƒì„±:', musicInfo);
            
            // ê¸°ë³¸ MusicXML í…œí”Œë¦¿
            const tempo = musicInfo.tempo || 120;
            const title = musicInfo.title || 'ë³€í™˜ëœ ì•…ë³´';
            
            let musicXML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <work>
    <work-title>${title}</work-title>
  </work>
  <part-list>
    <score-part id="P1">
      <part-name>ë³€í™˜ëœ íŒŒíŠ¸</part-name>
    </score-part>
  </part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>4</divisions>
        <key>
          <fifths>${getKeySignature(key)}</fifths>
        </key>
        <time>
          <beats>4</beats>
          <beat-type>4</beat-type>
        </time>
        <clef>
          <sign>G</sign>
          <line>2</line>
        </clef>
      </attributes>
      <direction placement="above">
        <direction-type>
          <metronome>
            <beat-unit>quarter</beat-unit>
            <per-minute>${tempo}</per-minute>
          </metronome>
        </direction-type>
      </direction>`;

            // ê°ì§€ëœ ì½”ë“œë¥¼ ìŒí‘œë¡œ ë³€í™˜
            if (musicInfo.chords && musicInfo.chords.length > 0) {
                let measureNotes = 0;
                for (let i = 0; i < Math.min(musicInfo.chords.length, 16); i++) {
                    const chord = musicInfo.chords[i];
                    const noteInfo = chordToNoteInfo(chord);
                    
                    if (noteInfo) {
                        musicXML += `
      <note>
        <pitch>
          <step>${noteInfo.step}</step>
          ${noteInfo.alter ? `<alter>${noteInfo.alter}</alter>` : ''}
          <octave>${noteInfo.octave}</octave>
        </pitch>
        <duration>4</duration>
        <type>quarter</type>
      </note>`;
                        
                        measureNotes++;
                        
                        // 4ê°œ ìŒí‘œë§ˆë‹¤ ìƒˆ ë§ˆë”” ìƒì„±
                        if (measureNotes === 4 && i < musicInfo.chords.length - 1) {
                            musicXML += `
    </measure>
    <measure number="${Math.floor(i/4) + 2}">`;
                            measureNotes = 0;
                        }
                    }
                }
            } else {
                // ê¸°ë³¸ ìŠ¤ì¼€ì¼
                const scaleNotes = getScaleNotes(key);
                for (let i = 0; i < Math.min(scaleNotes.length, 8); i++) {
                    const note = scaleNotes[i];
                    musicXML += `
      <note>
        <pitch>
          <step>${note.step}</step>
          ${note.alter ? `<alter>${note.alter}</alter>` : ''}
          <octave>4</octave>
        </pitch>
        <duration>4</duration>
        <type>quarter</type>
      </note>`;
                }
            }

            musicXML += `
    </measure>
  </part>
</score-partwise>`;

            return musicXML;
        }

        // ì½”ë“œëª…ì„ ìŒí‘œ ì •ë³´ë¡œ ë³€í™˜
        function chordToNoteInfo(chord) {
            const chordMap = {
                'C': { step: 'C', octave: 4 },
                'D': { step: 'D', octave: 4 },
                'E': { step: 'E', octave: 4 },
                'F': { step: 'F', octave: 4 },
                'G': { step: 'G', octave: 4 },
                'A': { step: 'A', octave: 4 },
                'B': { step: 'B', octave: 4 },
                'Eb': { step: 'E', alter: -1, octave: 4 },
                'Ab': { step: 'A', alter: -1, octave: 4 },
                'Bb': { step: 'B', alter: -1, octave: 4 }
            };

            // ê¸°ë³¸ ì½”ë“œëª… ì¶”ì¶œ (7th, m ë“± ì œê±°)
            const baseChord = chord.replace(/[m7]/g, '');
            return chordMap[baseChord] || chordMap['C'];
        }

        // ì¡°ì„±ì— ë”°ë¥¸ í‚¤ ì‹œê·¸ë‹ˆì²˜
        function getKeySignature(key) {
            const keyMap = { 'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5, 'F': -1, 'Bb': -2, 'Eb': -3 };
            return keyMap[key] || 0;
        }

        // ì¡°ì„±ì— ë§ëŠ” ìŠ¤ì¼€ì¼ ë…¸íŠ¸
        function getScaleNotes(key) {
            const scales = {
                'C': [
                    { step: 'C' }, { step: 'D' }, { step: 'E' }, { step: 'F' },
                    { step: 'G' }, { step: 'A' }, { step: 'B' }, { step: 'C' }
                ],
                'G': [
                    { step: 'G' }, { step: 'A' }, { step: 'B' }, { step: 'C' },
                    { step: 'D' }, { step: 'E' }, { step: 'F', alter: 1 }, { step: 'G' }
                ],
                'F': [
                    { step: 'F' }, { step: 'G' }, { step: 'A' }, { step: 'B', alter: -1 },
                    { step: 'C' }, { step: 'D' }, { step: 'E' }, { step: 'F' }
                ]
            };
            return scales[key] || scales['C'];
        }

        // MusicXMLì„ Verovioë¡œ MIDI ë³€í™˜
        async function convertMusicXMLToMIDI(musicXML) {
            if (!verovio) {
                throw new Error('Verovio íˆ´í‚·ì´ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ');
            }

            try {
                console.log('Verovioë¡œ MusicXML ë¡œë”©...');
                
                // MusicXMLì„ Verovioì— ë¡œë“œ
                const success = verovio.loadData(musicXML);
                if (!success) {
                    throw new Error('MusicXML ë¡œë”© ì‹¤íŒ¨');
                }

                console.log('MIDI ë°ì´í„° ìƒì„±...');
                
                // MIDI ë°”ì´íŠ¸ ë°°ì—´ ìƒì„±
                const midiBytes = verovio.renderToMIDI();
                if (!midiBytes || midiBytes.length === 0) {
                    throw new Error('MIDI ìƒì„± ì‹¤íŒ¨');
                }

                console.log('MIDI íŒŒì‹±...');
                
                // MIDI ë°”ì´íŠ¸ë¥¼ íŒŒì„œë¡œ ë³€í™˜
                const midiData = MidiParser.parse(new Uint8Array(midiBytes));
                console.log('Verovio MIDI ë³€í™˜ ì„±ê³µ:', midiData);
                
                return midiData;
                
            } catch (error) {
                console.error('Verovio MIDI ë³€í™˜ ì˜¤ë¥˜:', error);
                throw error;
            }
        }

        // MIDIë¥¼ MMLë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
        function convertMIDIToMML(midiData, key, includeChords, simplifyRhythm) {
            console.log('MIDI â†’ MML ë³€í™˜ ì‹œì‘:', midiData);
            
            if (!midiData.track || midiData.track.length === 0) {
                console.error('MIDI íŠ¸ë™ì´ ì—†ìŠµë‹ˆë‹¤');
                return generateDefaultMML(key, includeChords);
            }

            const ticksPerBeat = midiData.timeDivision || 480;
            let tracks = [];
            
            // ê° MIDI íŠ¸ë™ì„ ë¶„ì„
            for (let trackIndex = 0; trackIndex < Math.min(midiData.track.length, 3); trackIndex++) {
                const track = midiData.track[trackIndex];
                if (!track.event) continue;
                
                console.log(`íŠ¸ë™ ${trackIndex} ë¶„ì„:`, track.event.length, 'ì´ë²¤íŠ¸');
                
                const notes = [];
                let currentTempo = 120;
                
                for (const event of track.event) {
                    // í…œí¬ ë³€ê²½ ì´ë²¤íŠ¸
                    if (event.type === 255 && event.metaType === 81) {
                        // ë§ˆì´í¬ë¡œì´ˆ ë‹¨ìœ„ë¥¼ BPMìœ¼ë¡œ ë³€í™˜
                        const microsecondsPerBeat = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                        currentTempo = Math.round(60000000 / microsecondsPerBeat);
                        console.log('í…œí¬ ë³€ê²½:', currentTempo, 'BPM');
                    }
                    
                    // Note On ì´ë²¤íŠ¸ (9x)
                    if (event.type >= 144 && event.type <= 159 && event.data && event.data[1] > 0) {
                        const midiNote = event.data[0];
                        const velocity = event.data[1];
                        const deltaTime = event.deltaTime || 0;
                        
                        // MIDI ë…¸íŠ¸ ë²ˆí˜¸ë¥¼ MML ë…¸íŠ¸ë¡œ ë³€í™˜
                        const mmlNote = midiNoteToMML(midiNote);
                        if (mmlNote) {
                            // ê¸¸ì´ ê³„ì‚° (í‹±ì„ 4ë¶„ìŒí‘œ ê¸°ì¤€ìœ¼ë¡œ ë³€í™˜)
                            const duration = calculateNoteDuration(deltaTime, ticksPerBeat, simplifyRhythm);
                            
                            notes.push({
                                note: mmlNote.note,
                                octave: mmlNote.octave,
                                duration: duration,
                                velocity: velocity,
                                time: deltaTime
                            });
                        }
                    }
                }
                
                if (notes.length > 0) {
                    tracks.push({
                        notes: notes,
                        tempo: currentTempo
                    });
                }
            }
            
            if (tracks.length === 0) {
                console.warn('ë³€í™˜ ê°€ëŠ¥í•œ ìŒí‘œê°€ ì—†ìŠµë‹ˆë‹¤');
                return generateDefaultMML(key, includeChords);
            }
            
            // MML ë¬¸ìì—´ ìƒì„±
            let mml = `MML@t${tracks[0].tempo || 120}v12`;
            
            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                let currentOctave = 4;
                
                if (i > 0) mml += ',';
                if (i === 1) mml += 'v8o3'; // ë‘ ë²ˆì§¸ íŠ¸ë™ì€ ë‚®ì€ ë³¼ë¥¨, ë‚®ì€ ì˜¥íƒ€ë¸Œ
                
                for (const noteData of track.notes.slice(0, 32)) { // ìµœëŒ€ 32ê°œ ìŒí‘œ
                    // ì˜¥íƒ€ë¸Œ ë³€ê²½
                    if (noteData.octave !== currentOctave) {
                        const octaveDiff = noteData.octave - currentOctave;
                        if (octaveDiff > 0) {
                            mml += '>'.repeat(octaveDiff);
                        } else {
                            mml += '<'.repeat(-octaveDiff);
                        }
                        currentOctave = noteData.octave;
                    }
                    
                    // ìŒí‘œ ì¶”ê°€
                    mml += `${noteData.note}${noteData.duration}`;
                }
            }
            
            console.log('ìƒì„±ëœ MML:', mml + ';');
            return mml + ';';
        }

        // MIDI ë…¸íŠ¸ ë²ˆí˜¸ë¥¼ MML ë…¸íŠ¸ë¡œ ë³€í™˜
        function midiNoteToMML(midiNote) {
            if (midiNote < 0 || midiNote > 127) return null;
            
            const noteNames = ['c', 'c+', 'd', 'd+', 'e', 'f', 'f+', 'g', 'g+', 'a', 'a+', 'b'];
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            
            if (octave < 1 || octave > 8) return null;
            
            return {
                note: noteNames[noteIndex],
                octave: octave
            };
        }

        // ìŒí‘œ ê¸¸ì´ ê³„ì‚°
        function calculateNoteDuration(deltaTime, ticksPerBeat, simplifyRhythm) {
            if (deltaTime === 0) return 4; // ê¸°ë³¸ê°’
            
            // í‹±ì„ 4ë¶„ìŒí‘œ ê¸°ì¤€ìœ¼ë¡œ ë³€í™˜
            const quarterNoteRatio = deltaTime / ticksPerBeat;
            
            let duration;
            if (quarterNoteRatio >= 2) {
                duration = 2; // 2ë¶„ìŒí‘œ
            } else if (quarterNoteRatio >= 1) {
                duration = 4; // 4ë¶„ìŒí‘œ  
            } else if (quarterNoteRatio >= 0.5) {
                duration = 8; // 8ë¶„ìŒí‘œ
            } else {
                duration = 16; // 16ë¶„ìŒí‘œ
            }
            
            if (simplifyRhythm) {
                duration = Math.min(duration, 4); // ìµœëŒ€ 4ë¶„ìŒí‘œë¡œ ì œí•œ
            }
            
            return duration;
        }

        // ìƒ˜í”Œ MML ë¡œë“œ í•¨ìˆ˜ (ë§ˆë¹„ë…¸ê¸° í‘œì¤€ MML í˜•ì‹ìœ¼ë¡œ ìˆ˜ì •)
        function loadSampleMML(type) {
            const samples = {
                'twinkle': 'MML@t120v12o4ccggaag2ffeeddc2;',
                'canon': 'MML@t100v10o4cdefgab>c<bagfedc,o3c2g2c2g2f2c2f2g2;',
                'mary': 'MML@t110v11o4edcdeee2ddd2egg2edcdeeeeedede2c2;'
            };
            
            const sampleMML = samples[type];
            if (sampleMML) {
                console.log('ìƒ˜í”Œ MML ë¡œë“œë¨:', type, '-', sampleMML);
                displayResult(sampleMML);
                hideError();
                
                // ìƒ˜í”Œ ë¡œë“œ í›„ ë°”ë¡œ í…ŒìŠ¤íŠ¸ ì¬ìƒí•´ë³´ê¸° (ì„ íƒì‚¬í•­)
                setTimeout(() => {
                    console.log('ìƒ˜í”Œ MML ë¡œë“œ ì™„ë£Œ. ì´ì œ ë¯¸ë¦¬ë“£ê¸° ë²„íŠ¼ì„ í´ë¦­í•´ë³´ì„¸ìš”.');
                }, 100);
            }
        }

        // ì´ë¯¸ì§€ ì „ì²˜ë¦¬ í•¨ìˆ˜
        async function preprocessImage(file) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // ì´ë¯¸ì§€ë¥¼ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
                    ctx.drawImage(img, 0, 0);
                    
                    // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜ ë° ëŒ€ë¹„ í–¥ìƒ
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        const enhanced = gray < 128 ? 0 : 255; // ì´ì§„í™”
                        data[i] = enhanced;
                        data[i + 1] = enhanced;
                        data[i + 2] = enhanced;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    canvasContext = ctx;
                    resolve(canvas);
                };
                
                img.src = URL.createObjectURL(file);
            });
        }

        // ì˜¤ì„  ê°ì§€ í•¨ìˆ˜
        async function detectStaffLines(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const staffLines = [];
            
            // ìˆ˜í‰ì„  ê°ì§€ ì•Œê³ ë¦¬ì¦˜ (ì†ë„ ìµœì í™”)
            const stepY = Math.max(1, Math.floor(canvas.height / 200)); // ì ì‘ì  ìŠ¤ìº” ê°„ê²©
            const stepX = Math.max(5, Math.floor(canvas.width / 100)); // ì ì‘ì  ìŠ¤ìº” ê°„ê²©
            
            for (let y = 0; y < canvas.height; y += stepY) {
                let blackPixelCount = 0;
                const samplePoints = Math.min(50, Math.floor(canvas.width / stepX)); // ìƒ˜í”Œë§ í¬ì¸íŠ¸ ì œí•œ
                
                for (let i = 0; i < samplePoints; i++) {
                    const x = Math.floor((canvas.width / samplePoints) * i);
                    const pixelIndex = (y * canvas.width + x) * 4;
                    if (data[pixelIndex] < 128) blackPixelCount++;
                }
                
                // ì˜¤ì„ ìœ¼ë¡œ íŒë‹¨ë˜ëŠ” ì„ê³„ê°’ (ë” ê´€ëŒ€í•˜ê²Œ ì„¤ì •)
                if (blackPixelCount > samplePoints * 0.4) {
                    staffLines.push(y);
                }
            }
            
            // ì˜¤ì„  ê·¸ë£¹í™” (5ê°œì”© ë¬¶ì–´ì„œ í•˜ë‚˜ì˜ ì•…ë³´ ì‹œìŠ¤í…œìœ¼ë¡œ)
            const staffSystems = [];
            for (let i = 0; i < staffLines.length - 4; i += 5) {
                if (staffLines[i + 4] - staffLines[i] < 50) { // ì˜¤ì„  ê°„ê²©ì´ ì ì ˆí•œ ê²½ìš°
                    staffSystems.push(staffLines.slice(i, i + 5));
                    i += 4;
                }
            }
            
            return staffSystems;
        }

        // ìŒí‘œ ê°ì§€ í•¨ìˆ˜
        async function detectNotes(canvas, staffSystems) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const notes = [];
            
            for (const staffLines of staffSystems) {
                const systemNotes = [];
                
                // ê° ì˜¤ì„  ì‹œìŠ¤í…œì—ì„œ ìŒí‘œ ì°¾ê¸° (ì†ë„ ìµœì í™”)
                const stepX = Math.max(15, Math.floor(canvas.width / 80)); // í° ê°„ê²©ìœ¼ë¡œ ìŠ¤ìº”
                
                for (let x = 0; x < canvas.width; x += stepX) {
                    for (let i = 0; i < Math.min(staffLines.length, 5); i++) { // ìµœëŒ€ 5ê°œ ë¼ì¸ë§Œ ê²€ì‚¬
                        const y = staffLines[i];
                        
                        // ê°„ë‹¨í•œ ìŒí‘œ íŒ¨í„´ ê²€ì‚¬
                        if (isNotePatternFast(data, x, y, canvas.width)) {
                            const pitch = calculatePitch(y, staffLines);
                            const noteType = 'quarter'; // ì†ë„ë¥¼ ìœ„í•´ ê³ ì •ê°’ ì‚¬ìš©
                            
                            systemNotes.push({
                                x: x,
                                y: y,
                                pitch: pitch,
                                type: noteType,
                                duration: 4
                            });
                        }
                    }
                }
                
                notes.push(systemNotes);
            }
            
            return notes;
        }

        // ë¹ ë¥¸ ìŒí‘œ íŒ¨í„´ ì¸ì‹
        function isNotePatternFast(data, x, y, width) {
            // ë§¤ìš° ê°„ë‹¨í•œ íŒ¨í„´ ê²€ì‚¬ (ì†ë„ ìµœì í™”)
            const radius = 6;
            let blackPixels = 0;
            const checkPoints = 8; // ê²€ì‚¬í•  í¬ì¸íŠ¸ ìˆ˜ ì œí•œ
            
            for (let i = 0; i < checkPoints; i++) {
                const angle = (Math.PI * 2 * i) / checkPoints;
                const dx = Math.floor(radius * Math.cos(angle));
                const dy = Math.floor(radius * Math.sin(angle));
                const pixelX = x + dx;
                const pixelY = y + dy;
                
                if (pixelX >= 0 && pixelX < width && pixelY >= 0) {
                    const pixelIndex = (pixelY * width + pixelX) * 4;
                    if (data[pixelIndex] < 128) blackPixels++;
                }
            }
            
            return blackPixels >= 3; // ë” ê´€ëŒ€í•œ ì„ê³„ê°’
        }

        // ì›ë˜ ì •ë°€í•œ íŒ¨í„´ ì¸ì‹ (í•„ìš”ì‹œ ì‚¬ìš©)
        function isNotePattern(data, x, y, width) {
            // ê°„ë‹¨í•œ ì›í˜• íŒ¨í„´ ê²€ì‚¬
            let blackPixels = 0;
            const radius = 8;
            
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (dx*dx + dy*dy <= radius*radius) {
                        const pixelX = x + dx;
                        const pixelY = y + dy;
                        if (pixelX >= 0 && pixelX < width && pixelY >= 0) {
                            const pixelIndex = (pixelY * width + pixelX) * 4;
                            if (data[pixelIndex] < 128) blackPixels++;
                        }
                    }
                }
            }
            
            return blackPixels > radius * radius * 0.5;
        }

        // ìŒë†’ì´ ê³„ì‚°
        function calculatePitch(y, staffLines) {
            const pitches = ['e', 'f', 'g', 'a', 'b', 'c', 'd', 'e', 'f'];
            const lineHeight = (staffLines[4] - staffLines[0]) / 4;
            
            for (let i = 0; i < staffLines.length; i++) {
                const distance = Math.abs(y - staffLines[i]);
                if (distance < lineHeight / 2) {
                    return pitches[i + 2]; // ì˜¤ì„ ìƒì˜ ìŒí‘œ
                }
            }
            
            // ì˜¤ì„  ì‚¬ì´ì˜ ìŒí‘œ
            for (let i = 0; i < staffLines.length - 1; i++) {
                if (y > staffLines[i] && y < staffLines[i + 1]) {
                    return pitches[i + 2];
                }
            }
            
            return 'c'; // ê¸°ë³¸ê°’
        }

        // ìŒí‘œ íƒ€ì… ê°ì§€
        function detectNoteType(data, x, y, width) {
            // ê°„ë‹¨í•œ ìŒí‘œ íƒ€ì… ë¶„ë¥˜ (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ íŒ¨í„´ ì¸ì‹ í•„ìš”)
            return 'quarter'; // ê¸°ë³¸ì ìœ¼ë¡œ 4ë¶„ìŒí‘œë¡œ ì„¤ì •
        }

        // ìŒí‘œ ê¸¸ì´ ë°˜í™˜
        function getDuration(noteType) {
            const durations = {
                'whole': 1,
                'half': 2,
                'quarter': 4,
                'eighth': 8,
                'sixteenth': 16
            };
            return durations[noteType] || 4;
        }

        // ê°œì„ ëœ MML ì½”ë“œ ìƒì„± (ë§ˆë¹„ë…¸ê¸° í‘œì¤€ í˜•ì‹)
        function generateMMLFromNotes(notesSystems, key, includeChords, simplifyRhythm) {
            let mml = `MML@t120v12o4`;  // ê¸°ë³¸ ì„¤ì •: í…œí¬ 120, ë³¼ë¥¨ 12, ì˜¥íƒ€ë¸Œ 4
            
            for (const notes of notesSystems) {
                if (notes.length === 0) continue;
                
                // ìŒí‘œë“¤ì„ X ì¢Œí‘œ ìˆœìœ¼ë¡œ ì •ë ¬
                notes.sort((a, b) => a.x - b.x);
                
                let currentOctave = 4;
                
                for (const note of notes) {
                    // ì˜¥íƒ€ë¸Œ ë³€ê²½ í™•ì¸
                    const noteOctave = Math.floor(Math.random() * 3) + 3; // 3-5 ì˜¥íƒ€ë¸Œ ëœë¤
                    if (noteOctave !== currentOctave) {
                        if (noteOctave > currentOctave) {
                            mml += '>'.repeat(noteOctave - currentOctave);
                        } else {
                            mml += '<'.repeat(currentOctave - noteOctave);
                        }
                        currentOctave = noteOctave;
                    }
                    
                    // ìŒí‘œ ê¸¸ì´ ì¡°ì •
                    let duration = simplifyRhythm ? Math.min(note.duration, 2) : note.duration;
                    
                    // ë§ˆë¹„ë…¸ê¸° MML í˜•ì‹: ìŒí‘œì´ë¦„ + ê¸¸ì´ (c4, d2 ë“±)
                    mml += `${note.pitch}${duration}`;
                }
                
                // íŠ¸ë™ êµ¬ë¶„ì€ ì‰¼í‘œ ëŒ€ì‹  ì„¸ë¯¸ì½œë¡  ì „ì— ì¶”ê°€
                if (notesSystems.indexOf(notes) < notesSystems.length - 1) {
                    mml += ',';
                }
            }
            
            // í™”ìŒ ì¶”ê°€
            if (includeChords && notesSystems.length > 0) {
                mml += ',' + generateChordTrack(notesSystems[0], key);
            }
            
            return mml + ';';
        }

        // ê°œì„ ëœ í™”ìŒ íŠ¸ë™ ìƒì„± (ë§ˆë¹„ë…¸ê¸° í‘œì¤€ í˜•ì‹)
        function generateChordTrack(notes, key) {
            if (notes.length === 0) return '';
            
            let chordTrack = 'v8o3';  // í™”ìŒì€ ë‚®ì€ ë³¼ë¥¨, ë‚®ì€ ì˜¥íƒ€ë¸Œ
            const chordProgressions = {
                'C': ['c', 'f', 'g', 'c'],
                'G': ['g', 'c', 'd', 'g'],
                'F': ['f', 'a+', 'c', 'f']  // b- ëŒ€ì‹  a+ ì‚¬ìš©
            };
            
            const chords = chordProgressions[key] || chordProgressions['C'];
            
            for (let i = 0; i < Math.min(notes.length, 8); i++) {
                const chord = chords[i % chords.length];
                chordTrack += `${chord}2`;  // 2ë¶„ìŒí‘œë¡œ í™”ìŒ ì—°ì£¼
            }
            
            return chordTrack;
        }

        function displayResult(mml) {
            convertedMML = mml;
            document.getElementById('mmlOutput').textContent = mml;
            document.getElementById('resultSection').style.display = 'block';
        }

        function copyToClipboard() {
            navigator.clipboard.writeText(convertedMML).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'ë³µì‚¬ë¨!';
                btn.classList.add('success');
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('success');
                }, 2000);
            }).catch(() => {
                showError('í´ë¦½ë³´ë“œ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            });
        }

        function downloadMML() {
            const blob = new Blob([convertedMML], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mabinogi_music.mml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function resetConverter() {
            uploadedFile = null;
            convertedMML = '';
            fileInput.value = '';
            previewSection.style.display = 'none';
            document.getElementById('resultSection').style.display = 'none';
            convertBtn.disabled = true;
            hideError();
            
            // MIDI ë°ì´í„° ì´ˆê¸°í™”
            if (window.currentMidiData) {
                delete window.currentMidiData;
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìƒì„±ë¨, ìƒíƒœ:', audioContext.state);
                } catch (error) {
                    console.error('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìƒì„± ì‹¤íŒ¨:', error);
                    showError('ì˜¤ë””ì˜¤ ì¬ìƒì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.');
                    return null;
                }
            }
            return audioContext;
        }

        // ìŒí‘œ ì£¼íŒŒìˆ˜ ë§¤í•‘
        function getNoteFrequency(note, octave = 4) {
            const noteFrequencies = {
                'c': 261.63,
                'c+': 277.18, 'c#': 277.18,
                'd': 293.66,
                'd+': 311.13, 'd#': 311.13,
                'e': 329.63,
                'f': 349.23,
                'f+': 369.99, 'f#': 369.99,
                'g': 392.00,
                'g+': 415.30, 'g#': 415.30,
                'a': 440.00,
                'a+': 466.16, 'a#': 466.16,
                'b': 493.88
            };
            
            const baseFreq = noteFrequencies[note.toLowerCase()] || 440;
            return baseFreq * Math.pow(2, octave - 4);
        }

        // ê°œì„ ëœ MML íŒŒì‹± í•¨ìˆ˜ (ë§ˆë¹„ë…¸ê¸° í‘œì¤€ MML ì§€ì›)
        function parseMML(mml) {
            console.log('íŒŒì‹±í•  MML:', mml);
            
            // MML@ ì œê±°í•˜ê³  ì„¸ë¯¸ì½œë¡ ìœ¼ë¡œ ëë‚˜ëŠ”ì§€ í™•ì¸
            let cleanMML = mml.replace(/^MML@/i, '').replace(/;$/, '');
            
            // ì‰¼í‘œë¡œ íŠ¸ë™ ë¶„ë¦¬í•˜ë˜, ë¹ˆ íŠ¸ë™ ì œê±°
            const tracks = cleanMML.split(',').filter(track => track.trim() !== '' && track.trim().length > 0);
            console.log('ë¶„ë¦¬ëœ íŠ¸ë™ë“¤:', tracks);
            
            const parsedTracks = [];
            
            for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
                const track = tracks[trackIndex].trim();
                if (!track) continue;
                
                const notes = [];
                let currentTempo = 120;
                let currentVolume = 10;
                let currentOctave = 4;
                let currentDefaultLength = 4;
                let i = 0;
                
                console.log(`íŠ¸ë™ ${trackIndex + 1} íŒŒì‹± ì‹œì‘:`, track);
                
                while (i < track.length) {
                    const char = track[i].toLowerCase();
                    
                    // í…œí¬ ì„¤ì • (t)
                    if (char === 't') {
                        i++;
                        let tempo = '';
                        while (i < track.length && track[i] >= '0' && track[i] <= '9') {
                            tempo += track[i];
                            i++;
                        }
                        currentTempo = parseInt(tempo) || 120;
                        console.log('í…œí¬ ì„¤ì •:', currentTempo);
                        continue;
                    }
                    
                    // ë³¼ë¥¨ ì„¤ì • (v)
                    if (char === 'v') {
                        i++;
                        let volume = '';
                        while (i < track.length && track[i] >= '0' && track[i] <= '9') {
                            volume += track[i];
                            i++;
                        }
                        currentVolume = parseInt(volume) || 10;
                        console.log('ë³¼ë¥¨ ì„¤ì •:', currentVolume);
                        continue;
                    }
                    
                    // ì˜¥íƒ€ë¸Œ ì„¤ì • (o)
                    if (char === 'o') {
                        i++;
                        let octave = '';
                        while (i < track.length && track[i] >= '0' && track[i] <= '9') {
                            octave += track[i];
                            i++;
                        }
                        currentOctave = parseInt(octave) || 4;
                        console.log('ì˜¥íƒ€ë¸Œ ì„¤ì •:', currentOctave);
                        continue;
                    }
                    
                    // ê¸°ë³¸ ê¸¸ì´ ì„¤ì • (l)
                    if (char === 'l') {
                        i++;
                        let length = '';
                        while (i < track.length && track[i] >= '0' && track[i] <= '9') {
                            length += track[i];
                            i++;
                        }
                        currentDefaultLength = parseInt(length) || 4;
                        console.log('ê¸°ë³¸ ê¸¸ì´ ì„¤ì •:', currentDefaultLength);
                        continue;
                    }
                    
                    // ì˜¥íƒ€ë¸Œ ë³€ê²½
                    if (char === '>') {
                        currentOctave = Math.min(currentOctave + 1, 8);
                        console.log('ì˜¥íƒ€ë¸Œ ì¦ê°€:', currentOctave);
                        i++;
                        continue;
                    }
                    
                    if (char === '<') {
                        currentOctave = Math.max(currentOctave - 1, 1);
                        console.log('ì˜¥íƒ€ë¸Œ ê°ì†Œ:', currentOctave);
                        i++;
                        continue;
                    }
                    
                    // íœ´í‘œ (r)
                    if (char === 'r') {
                        i++;
                        let duration = '';
                        while (i < track.length && track[i] >= '0' && track[i] <= '9') {
                            duration += track[i];
                            i++;
                        }
                        const restDuration = parseInt(duration) || currentDefaultLength;
                        
                        notes.push({
                            type: 'rest',
                            duration: restDuration,
                            tempo: currentTempo,
                            volume: currentVolume
                        });
                        console.log('íœ´í‘œ ì¶”ê°€:', restDuration);
                        continue;
                    }
                    
                    // ìŒí‘œ (c, d, e, f, g, a, b)
                    if ('cdefgab'.includes(char)) {
                        let noteName = char;
                        i++;
                        
                        // ìƒµ/í”Œë« í™•ì¸
                        if (i < track.length && (track[i] === '+' || track[i] === '#')) {
                            noteName += '+';
                            i++;
                        } else if (i < track.length && track[i] === '-') {
                            // í”Œë«ì„ ìƒµìœ¼ë¡œ ë³€í™˜ (ê°„ë‹¨í™”)
                            const flatToSharp = {
                                'a-': 'g+', 'b-': 'a+', 'd-': 'c+',
                                'e-': 'd+', 'g-': 'f+'
                            };
                            noteName = flatToSharp[noteName + '-'] || noteName;
                            i++;
                        }
                        
                        // ìŒí‘œ ê¸¸ì´ í™•ì¸
                        let duration = '';
                        while (i < track.length && track[i] >= '0' && track[i] <= '9') {
                            duration += track[i];
                            i++;
                        }
                        const noteDuration = parseInt(duration) || currentDefaultLength;
                        
                        // ë„íŠ¸ í™•ì¸ (.)
                        let isDotted = false;
                        if (i < track.length && track[i] === '.') {
                            isDotted = true;
                            i++;
                        }
                        
                        const frequency = getNoteFrequency(noteName, currentOctave);
                        
                        notes.push({
                            type: 'note',
                            note: noteName,
                            octave: currentOctave,
                            duration: noteDuration,
                            isDotted: isDotted,
                            frequency: frequency,
                            tempo: currentTempo,
                            volume: currentVolume
                        });
                        
                        console.log(`ìŒí‘œ ì¶”ê°€: ${noteName}${currentOctave}, ê¸¸ì´: ${noteDuration}, ì£¼íŒŒìˆ˜: ${frequency.toFixed(2)}Hz`);
                        continue;
                    }
                    
                    // ê¸°íƒ€ ë¬¸ìëŠ” ë¬´ì‹œ
                    i++;
                }
                
                if (notes.length > 0) {
                    parsedTracks.push({
                        notes: notes,
                        tempo: currentTempo,
                        volume: currentVolume
                    });
                    console.log(`íŠ¸ë™ ${trackIndex + 1} íŒŒì‹± ì™„ë£Œ: ${notes.length}ê°œ ìš”ì†Œ`);
                }
            }
            
            console.log('ì „ì²´ íŒŒì‹± ì™„ë£Œ:', parsedTracks.length, 'ê°œ íŠ¸ë™');
            return parsedTracks;
        }

        // ê°œì„ ëœ ì‚¬ìš´ë“œ ì¬ìƒ í•¨ìˆ˜
        function playNote(frequency, duration, startTime, volume = 0.1) {
            if (!audioContext) return null;
            
            // ë©”ì¸ ì˜¤ì‹¤ë ˆì´í„° (ê¸°ë³¸ í†¤)
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // ë°°ìŒ ì¶”ê°€ë¥¼ ìœ„í•œ ì„œë¸Œ ì˜¤ì‹¤ë ˆì´í„° (ë” í’ë¶€í•œ ì‚¬ìš´ë“œ)
            const subOscillator = audioContext.createOscillator();
            const subGainNode = audioContext.createGain();
            
            // í•„í„° ì¶”ê°€ (ìŒì§ˆ ê°œì„ )
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(3000, startTime);
            filter.Q.setValueAtTime(1, startTime);
            
            // ì—°ê²°: ì˜¤ì‹¤ë ˆì´í„° -> í•„í„° -> ê²Œì¸ -> ì¶œë ¥
            oscillator.connect(filter);
            subOscillator.connect(subGainNode);
            filter.connect(gainNode);
            subGainNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // ë©”ì¸ ì˜¤ì‹¤ë ˆì´í„° ì„¤ì •
            oscillator.frequency.setValueAtTime(frequency, startTime);
            oscillator.type = 'triangle';  // sineë³´ë‹¤ ë”°ëœ»í•œ ì†Œë¦¬
            
            // ì„œë¸Œ ì˜¤ì‹¤ë ˆì´í„° ì„¤ì • (ì˜¥íƒ€ë¸Œ ìœ„)
            subOscillator.frequency.setValueAtTime(frequency * 2, startTime);
            subOscillator.type = 'sine';
            
            // ë³¼ë¥¨ ì¡°ì ˆ (ê°œì„ ëœ ì—”ë¹Œë¡œí”„)
            const attackTime = 0.02;   // ë¹ ë¥¸ ì–´íƒ
            const decayTime = 0.1;     // ì§§ì€ ë””ì¼€ì´
            const sustainLevel = 0.7;  // ì„œìŠ¤í…Œì¸ ë ˆë²¨
            const releaseTime = 0.2;   // ë¦´ë¦¬ì¦ˆ ì‹œê°„
            
            const finalVolume = volume * 0.8; // ì „ì²´ ë³¼ë¥¨ ì¡°ì ˆ
            const subVolume = finalVolume * 0.3; // ì„œë¸Œ ì˜¤ì‹¤ë ˆì´í„° ë³¼ë¥¨
            
            // ë©”ì¸ ê²Œì¸ ì—”ë¹Œë¡œí”„
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(finalVolume, startTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(finalVolume * sustainLevel, startTime + attackTime + decayTime);
            gainNode.gain.setValueAtTime(finalVolume * sustainLevel, startTime + Math.max(duration - releaseTime, attackTime + decayTime));
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
            
            // ì„œë¸Œ ê²Œì¸ ì—”ë¹Œë¡œí”„ (ë” ë¶€ë“œëŸ½ê²Œ)
            subGainNode.gain.setValueAtTime(0, startTime);
            subGainNode.gain.linearRampToValueAtTime(subVolume, startTime + attackTime * 1.5);
            subGainNode.gain.linearRampToValueAtTime(subVolume * sustainLevel, startTime + attackTime * 1.5 + decayTime);
            subGainNode.gain.setValueAtTime(subVolume * sustainLevel, startTime + Math.max(duration - releaseTime, attackTime + decayTime));
            subGainNode.gain.linearRampToValueAtTime(0, startTime + duration);
            
            // ì˜¤ì‹¤ë ˆì´í„° ì‹œì‘/ì •ì§€
            oscillator.start(startTime);
            subOscillator.start(startTime);
            oscillator.stop(startTime + duration);
            subOscillator.stop(startTime + duration);
            
            // í™œì„± ì˜¤ì‹¤ë ˆì´í„° ì¶”ê°€
            activeOscillators.push(oscillator, subOscillator);
            
            // ì¢…ë£Œ í›„ ë°°ì—´ì—ì„œ ì œê±°
            const cleanup = () => {
                const index1 = activeOscillators.indexOf(oscillator);
                const index2 = activeOscillators.indexOf(subOscillator);
                if (index1 > -1) activeOscillators.splice(index1, 1);
                if (index2 > -1) activeOscillators.splice(index2, 1);
            };
            
            oscillator.onended = cleanup;
            subOscillator.onended = cleanup;
            
            return oscillator;
        }

        // ê°œì„ ëœ MML ì¬ìƒ í•¨ìˆ˜
        async function playMML(mml) {
            console.log('MML ì¬ìƒ ì‹œì‘:', mml.substring(0, 50) + '...');
            
            const ctx = initAudioContext();
            if (!ctx) {
                console.error('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨');
                return;
            }
            
            console.log('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìƒíƒœ:', ctx.state);
            
            if (ctx.state === 'suspended') {
                console.log('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì¬ê°œ ì¤‘...');
                await ctx.resume();
                console.log('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì¬ê°œë¨, ìƒˆ ìƒíƒœ:', ctx.state);
            }
            
            const parsedTracks = parseMML(mml);
            console.log('íŒŒì‹±ëœ íŠ¸ë™ ìˆ˜:', parsedTracks.length);
            
            if (parsedTracks.length === 0) {
                console.log('ì¬ìƒí•  íŠ¸ë™ì´ ì—†ìŒ');
                showError('ì¬ìƒí•  ìˆ˜ ìˆëŠ” ìŒí‘œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            // ì²« ë²ˆì§¸ íŠ¸ë™ì˜ ì •ë³´ ì¶œë ¥
            if (parsedTracks[0] && parsedTracks[0].notes && parsedTracks[0].notes.length > 0) {
                console.log('ì²« ë²ˆì§¸ ìŒí‘œ:', parsedTracks[0].notes[0]);
                console.log('íŠ¸ë™ í…œí¬:', parsedTracks[0].tempo);
            }
            
            // UI í…œí¬ ìŠ¬ë¼ì´ë”ì˜ ê°’ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ë˜, MMLì˜ í…œí¬ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
            const uiTempo = parseInt(document.getElementById('tempoSlider')?.value || 120);
            
            let currentTime = ctx.currentTime + 0.1;
            let maxDuration = 0;
            let totalNotes = 0;
            
            // ëª¨ë“  íŠ¸ë™ì„ ë™ì‹œì— ì¬ìƒ
            for (let trackIndex = 0; trackIndex < parsedTracks.length; trackIndex++) {
                const trackData = parsedTracks[trackIndex];
                const track = trackData.notes;
                const trackTempo = trackData.tempo || uiTempo;
                const beatDuration = 60 / trackTempo; // 1ë°•ì ì‹œê°„(ì´ˆ)
                
                let trackTime = currentTime;
                
                console.log(`íŠ¸ë™ ${trackIndex + 1}: ${track.length}ê°œ ìŒí‘œ, í…œí¬: ${trackTempo} BPM`);
                
                for (let noteIndex = 0; noteIndex < track.length; noteIndex++) {
                    const noteData = track[noteIndex];
                    let noteDuration = (4 / noteData.duration) * beatDuration;
                    
                    // ë„íŠ¸ ìŒí‘œ ì²˜ë¦¬ (1.5ë°° ê¸¸ì´)
                    if (noteData.isDotted) {
                        noteDuration *= 1.5;
                    }
                    
                    if (noteData.type === 'note') {
                        // MMLì˜ ë³¼ë¥¨ê³¼ UI ë³¼ë¥¨ ì¡°í•©
                        const uiVolume = (document.getElementById('volumeSlider')?.value || 50) / 100;
                        const mmlVolume = (noteData.volume || 10) / 15; // MML ë³¼ë¥¨ì„ 0-1 ë²”ìœ„ë¡œ ì •ê·œí™”
                        const finalVolume = Math.min(uiVolume * mmlVolume * 0.3, 0.3); // ìµœëŒ€ ë³¼ë¥¨ ì œí•œ
                        
                        console.log(`ìŒí‘œ ì¬ìƒ: ${noteData.note}${noteData.octave}, ì£¼íŒŒìˆ˜: ${noteData.frequency.toFixed(2)}Hz, ì‹œê°„: ${trackTime.toFixed(2)}ì´ˆ, ê¸¸ì´: ${noteDuration.toFixed(2)}ì´ˆ, ë³¼ë¥¨: ${finalVolume.toFixed(3)}`);
                        playNote(noteData.frequency, noteDuration, trackTime, finalVolume);
                        totalNotes++;
                    } else if (noteData.type === 'rest') {
                        console.log(`íœ´í‘œ: ${noteDuration.toFixed(2)}ì´ˆ`);
                    }
                    
                    trackTime += noteDuration;
                }
                
                const trackDuration = trackTime - currentTime;
                maxDuration = Math.max(maxDuration, trackDuration);
                console.log(`íŠ¸ë™ ${trackIndex + 1} ì¬ìƒ ì‹œê°„: ${trackDuration.toFixed(2)}ì´ˆ`);
            }
            
            console.log(`ì´ ${totalNotes}ê°œ ìŒí‘œ ì¬ìƒ ì˜ˆì•½ë¨, ì „ì²´ ì¬ìƒ ì‹œê°„: ${maxDuration.toFixed(2)}ì´ˆ`);
            
            // ì¬ìƒ ì™„ë£Œ í›„ ë²„íŠ¼ ìƒíƒœ ë³µì›
            currentTimeout = setTimeout(() => {
                console.log('ì¬ìƒ ì™„ë£Œ');
                stopPlayback();
            }, Math.max(maxDuration * 1000, 1000)); // ìµœì†Œ 1ì´ˆëŠ” ì¬ìƒ
        }

        // ì¬ìƒ/ì¼ì‹œì •ì§€ í† ê¸€
        async function togglePlayback() {
            const playBtn = document.getElementById('playBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (!convertedMML) {
                showError('ì¬ìƒí•  MML ì½”ë“œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            if (isPlaying) {
                // ì¼ì‹œì •ì§€
                console.log('ì¬ìƒ ì¤‘ë‹¨');
                stopPlayback();
            } else {
                // ì¬ìƒ ì‹œì‘
                try {
                    console.log('ì¬ìƒ ë²„íŠ¼ í´ë¦­ë¨');
                    hideError(); // ê¸°ì¡´ ì˜¤ë¥˜ ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
                    
                    // ì‚¬ìš©ì ì œìŠ¤ì²˜ë¡œ ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
                    const ctx = initAudioContext();
                    if (!ctx) {
                        throw new Error('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì´ˆê¸°í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    // ë¸Œë¼ìš°ì € ì •ì±…ìœ¼ë¡œ ì¸í•´ suspended ìƒíƒœì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê°•ì œë¡œ ì¬ê°œ
                    if (ctx.state === 'suspended') {
                        console.log('ì‚¬ìš©ì ì œìŠ¤ì²˜ë¡œ ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì¬ê°œ ì‹œë„');
                        await ctx.resume();
                        console.log('ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìƒíƒœ ë³€ê²½ë¨:', ctx.state);
                    }
                    
                    isPlaying = true;
                    playBtn.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
                    playBtn.classList.add('playing');
                    stopBtn.disabled = false;
                    
                    await playMML(convertedMML);
                } catch (error) {
                    console.error('ì¬ìƒ ì¤‘ ì˜¤ë¥˜:', error);
                    showError('ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                    stopPlayback();
                }
            }
        }

        // ì¬ìƒ ì •ì§€
        function stopPlayback() {
            isPlaying = false;
            
            if (currentTimeout) {
                clearTimeout(currentTimeout);
                currentTimeout = null;
            }
            
            // í™œì„± ì˜¤ì‹¤ë ˆì´í„°ë“¤ ì •ì§€
            activeOscillators.forEach(oscillator => {
                try {
                    oscillator.stop();
                } catch (e) {
                    // ì´ë¯¸ ì •ì§€ëœ ì˜¤ì‹¤ë ˆì´í„°ëŠ” ë¬´ì‹œ
                }
            });
            activeOscillators = [];
            
            // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë‹«ì§€ ë§ê³  suspend ìƒíƒœë¡œ ì „í™˜ (ì¬ì‚¬ìš© ê°€ëŠ¥)
            if (audioContext && audioContext.state === 'running') {
                audioContext.suspend();
            }
            
            const playBtn = document.getElementById('playBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (playBtn) {
                playBtn.textContent = 'â–¶ï¸ ë¯¸ë¦¬ë“£ê¸°';
                playBtn.classList.remove('playing');
            }
            
            if (stopBtn) {
                stopBtn.disabled = true;
            }
        }
    </script>
</body>
</html>